<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aim Sensitivity Finder</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        
        :root {
            --bg-color: #121212;
            --primary-color: #00e676; /* Neon Green */
            --accent-color: #ff3d00; /* Neon Orange/Red */
            --text-color: #e0e0e0;
            --card-bg: #1e1e1e;
        }

        body {
            font-family: 'Orbitron', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }

        .container {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 1000px;
            gap: 20px;
        }

        .main-content {
            display: flex;
            flex-direction: row;
            gap: 20px;
        }

        .game-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            color: var(--primary-color);
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.8rem;
            text-shadow: 0 0 10px rgba(0, 230, 118, 0.5);
        }

        /* Game Canvas and Reticle */
        #gameCanvas {
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0, 230, 118, 0.4);
            cursor: none; /* Hide default cursor */
            background-color: #0d0d0d;
            touch-action: none; /* Prevent default touch scrolling/gestures */
        }

        .reticle {
            position: absolute;
            width: 20px;
            height: 20px;
            pointer-events: none; /* Allows clicks to pass through */
            transform: translate(-50%, -50%);
            transition: opacity 0.1s;
            opacity: 1;
        }

        .reticle-center {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background-color: var(--accent-color);
            transform: translate(-50%, -50%);
        }

        .reticle-line {
            position: absolute;
            background-color: var(--accent-color);
        }

        .reticle-h1, .reticle-h2 {
            width: 8px;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        .reticle-h1 { left: 0; }
        .reticle-h2 { right: 0; }

        .reticle-v1, .reticle-v2 {
            width: 2px;
            height: 8px;
            left: 50%;
            transform: translateX(-50%);
        }
        .reticle-v1 { top: 0; }
        .reticle-v2 { bottom: 0; }
        
        /* Sidebar/Info Panel */
        .info-panel {
            width: 280px;
            min-width: 280px;
            background-color: var(--card-bg);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #333;
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.5);
        }

        .info-panel h2 {
            color: var(--primary-color);
            font-size: 1.3rem;
            margin-top: 0;
            margin-bottom: 15px;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 5px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 5px 0;
            border-bottom: 1px dashed #333;
        }

        .stat-label {
            color: var(--text-color);
        }

        .stat-value {
            color: var(--accent-color);
            font-weight: 700;
        }

        .stat-item:last-child {
            border-bottom: none;
        }

        .controls button {
            width: 100%;
            padding: 12px;
            margin-top: 20px;
            background-color: var(--accent-color);
            color: var(--bg-color);
            border: none;
            border-radius: 4px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
            box-shadow: 0 4px 0 #b32a00;
        }

        .controls button:hover {
            background-color: #ff5233;
        }

        .controls button:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #b32a00;
        }

        /* Results Modal */
        #resultsModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .modal-content {
            background-color: var(--card-bg);
            padding: 30px;
            border-radius: 10px;
            max-width: 400px;
            text-align: center;
            border: 2px solid var(--primary-color);
            box-shadow: 0 0 25px rgba(0, 230, 118, 0.7);
        }

        .modal-content h3 {
            color: var(--primary-color);
            font-size: 1.5rem;
            margin-top: 0;
        }
        
        #suggestionText {
            font-size: 1.1rem;
            line-height: 1.6;
            margin: 20px 0;
        }

        .modal-content button {
            background-color: var(--primary-color);
            color: var(--bg-color);
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .modal-content button:hover {
            background-color: #38ff99;
        }

        .hidden {
            display: none;
        }

        /* Responsive Layout */
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            .info-panel {
                width: 100%;
                min-width: auto;
            }
            .container {
                padding: 10px;
            }
            h1 {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Sensitivity Finder: The Flick Test</h1>
        <div class="main-content">
            <!-- Game Canvas Area -->
            <div class="game-area">
                <canvas id="gameCanvas" width="700" height="500"></canvas>
                <!-- Custom Reticle (controlled by JS) -->
                <div id="reticle" class="reticle hidden">
                    <div class="reticle-center"></div>
                    <div class="reticle-line reticle-h1"></div>
                    <div class="reticle-line reticle-h2"></div>
                    <div class="reticle-line reticle-v1"></div>
                    <div class="reticle-line reticle-v2"></div>
                </div>
            </div>

            <!-- Info and Controls Panel -->
            <div class="info-panel">
                <h2>Game Stats</h2>
                <div class="stats">
                    <div class="stat-item">
                        <span class="stat-label">Shots Taken</span>
                        <span id="shotsTaken" class="stat-value">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Shots Left</span>
                        <span id="shotsLeft" class="stat-value">10</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Total Time (s)</span>
                        <span id="totalTime" class="stat-value">0.00</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Avg Reaction (ms)</span>
                        <span id="avgReaction" class="stat-value">N/A</span>
                    </div>
                </div>

                <div class="controls">
                    <p style="text-align: center; font-size: 0.9rem; margin-top: 15px;">Flick from center to target and click.</p>
                    <button id="startButton">START TEST (10 Shots)</button>
                </div>
                
                <h2 style="margin-top: 30px;">Analysis Data</h2>
                <div class="stats">
                    <div class="stat-item">
                        <span class="stat-label">Avg Overshoot (px)</span>
                        <span id="avgOvershoot" class="stat-value">0.00</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Avg Undershoot (px)</span>
                        <span id="avgUndershoot" class="stat-value">0.00</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Sensitivity Suggestion</span>
                        <span id="suggestion" class="stat-value" style="color: var(--text-color); font-weight: 400;">(Run Test First)</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Results Modal -->
    <div id="resultsModal" class="hidden">
        <div class="modal-content">
            <h3>Test Complete!</h3>
            <p id="modalStats"></p>
            <p id="suggestionText"></p>
            <button onclick="closeModal()">Try Again</button>
        </div>
    </div>

    <script>
        // --- Firebase/Auth/Firestore setup boilerplate ---
        // Note: Firestore is not used for this single-player game, but the variables are included as per standard instruction.
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        // const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        // const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : undefined;
        // ---------------------------------------------------

        // Canvas and Context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const reticle = document.getElementById('reticle');
        
        // Game State
        const MAX_SHOTS = 10;
        const TARGET_RADIUS = 20;
        const FLICK_DISTANCE = 200; // Fixed distance from center to target
        let isGameRunning = false;
        let shotsTaken = 0;
        let target = null;
        let startTime = 0;
        let reactionTimes = [];
        let overshootErrors = []; // Errors that are past the target center
        let undershootErrors = []; // Errors that are short of the target center
        let gameLoopInterval = null;

        // UI Elements
        const shotsTakenEl = document.getElementById('shotsTaken');
        const shotsLeftEl = document.getElementById('shotsLeft');
        const totalTimeEl = document.getElementById('totalTime');
        const avgReactionEl = document.getElementById('avgReaction');
        const startButton = document.getElementById('startButton');
        const avgOvershootEl = document.getElementById('avgOvershoot');
        const avgUndershootEl = document.getElementById('avgUndershoot');
        const suggestionEl = document.getElementById('suggestion');
        const resultsModal = document.getElementById('resultsModal');
        const suggestionTextEl = document.getElementById('suggestionText');
        const modalStatsEl = document.getElementById('modalStats');
        
        // Reticle positioning variables
        let reticleX = canvas.width / 2;
        let reticleY = canvas.height / 2;

        /**
         * Target Class
         */
        class Target {
            constructor(x, y, radius) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = varToHex('primary-color');
            }

            draw() {
                // Outer glow
                ctx.shadowBlur = 10;
                ctx.shadowColor = 'rgba(0, 230, 118, 0.8)';
                
                // Outer circle
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // Inner circle (bullseye)
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius / 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Checks if a click (mx, my) hit the target
            checkHit(mx, my) {
                const distance = Math.sqrt((mx - this.x) ** 2 + (my - this.y) ** 2);
                return distance <= this.radius;
            }
        }
        
        /**
         * Utility function to get CSS variable value (for Canvas drawing)
         */
        function varToHex(cssVar) {
            return getComputedStyle(document.documentElement).getPropertyValue(`--${cssVar}`).trim();
        }

        /**
         * Calculates a new target position at a fixed distance from the center.
         */
        function getNewTargetPosition() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // Generate a random angle
            const angle = Math.random() * 2 * Math.PI;

            // Calculate x and y coordinates on the circle perimeter
            let x = centerX + FLICK_DISTANCE * Math.cos(angle);
            let y = centerY + FLICK_DISTANCE * Math.sin(angle);
            
            // Ensure the target is fully visible on the canvas
            const padding = TARGET_RADIUS + 5;
            x = Math.max(padding, Math.min(canvas.width - padding, x));
            y = Math.max(padding, Math.min(canvas.height - padding, y));

            return { x, y };
        }

        /**
         * Starts a new game round.
         */
        function startNewRound() {
            if (shotsTaken >= MAX_SHOTS) {
                endGame();
                return;
            }

            // Reset mouse to center for the flick
            reticleX = canvas.width / 2;
            reticleY = canvas.height / 2;
            updateReticlePosition();
            
            // Generate new target
            const pos = getNewTargetPosition();
            target = new Target(pos.x, pos.y, TARGET_RADIUS);

            startTime = performance.now();
            updateStats();
        }
        
        /**
         * Game loop (for drawing)
         */
        function gameLoop() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = varToHex('bg-color');
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw center point
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.arc(canvas.width / 2, canvas.height / 2, 5, 0, Math.PI * 2);
            ctx.fill();

            // Draw target if exists
            if (target) {
                target.draw();
            }
            
            // Update total time display
            if (isGameRunning && shotsTaken > 0 && shotsTaken < MAX_SHOTS) {
                const currentTime = (performance.now() - gameStartTime) / 1000;
                totalTimeEl.textContent = currentTime.toFixed(2);
            }

            gameLoopInterval = requestAnimationFrame(gameLoop);
        }

        /**
         * Handles mouse click on the canvas.
         */
        function handleFlick(e) {
            if (!isGameRunning || !target) return;
            
            // Calculate click position relative to canvas
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            
            // 1. Check if the target was hit
            const hit = target.checkHit(clickX, clickY);

            if (hit) {
                const endTime = performance.now();
                const reactionTime = endTime - startTime;
                reactionTimes.push(reactionTime);
                
                shotsTaken++;

                // 2. Calculate error for sensitivity analysis
                // Vector from center (start point) to hit point
                const startX = canvas.width / 2;
                const startY = canvas.height / 2;
                
                const hitVecX = clickX - startX;
                const hitVecY = clickY - startY;
                const hitDist = Math.sqrt(hitVecX ** 2 + hitVecY ** 2);
                
                // Vector from center (start point) to target center
                const targetVecX = target.x - startX;
                const targetVecY = target.y - startY;
                
                // Project the hit vector onto the target vector to find the directional error
                const targetDist = FLICK_DISTANCE; // Should be the same as FLICK_DISTANCE

                // Dot product / magnitude squared for normalized projection
                const dotProduct = hitVecX * targetVecX + hitVecY * targetVecY;
                const magnitudeSq = targetVecX ** 2 + targetVecY ** 2;
                
                // Projection factor 'p' (how far along the target vector the hit landed)
                const projectionFactor = dotProduct / magnitudeSq; 
                
                // The distance of the hit *along* the intended flick line from the start point
                const projectedHitDist = projectionFactor * targetDist;

                const error = projectedHitDist - targetDist;
                
                if (error > 0) {
                    // Overshoot: The mouse landed beyond the target's center along the flick line
                    overshootErrors.push(error);
                } else {
                    // Undershoot/Perfect hit: The mouse landed before the target's center along the flick line
                    // We only log undershoot if it's outside the target radius
                    const errorMagnitude = Math.abs(error);
                    if (errorMagnitude > TARGET_RADIUS) {
                        undershootErrors.push(errorMagnitude);
                    }
                }

                // 3. Start next round
                startNewRound();
            } else {
                // Missed the target (optional: add penalty or ignore, we ignore for a sensitivity test)
                // console.log("Miss!");
            }
        }
        
        /**
         * Updates the custom reticle position based on mouse/touch input.
         */
        function updateReticlePosition() {
            const rect = canvas.getBoundingClientRect();
            reticle.style.left = `${reticleX + rect.left}px`;
            reticle.style.top = `${reticleY + rect.top}px`;
        }

        /**
         * Handles mouse movement to control the reticle
         */
        function handleMouseMove(e) {
            if (!isGameRunning) return;
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Ensure reticle stays within bounds of the canvas
            reticleX = Math.max(0, Math.min(canvas.width, mouseX));
            reticleY = Math.max(0, Math.min(canvas.height, mouseY));
            
            updateReticlePosition();
        }

        /**
         * Handles touch movement for the reticle (simulating a mouse)
         */
        function handleTouchMove(e) {
            if (!isGameRunning || e.touches.length !== 1) return;
            e.preventDefault(); // Prevent scrolling
            
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;

            // Ensure reticle stays within bounds of the canvas
            reticleX = Math.max(0, Math.min(canvas.width, touchX));
            reticleY = Math.max(0, Math.min(canvas.height, touchY));
            
            updateReticlePosition();
        }

        /**
         * Handles touch end for the click action
         */
        function handleTouchEnd(e) {
            if (!isGameRunning) return;
            // Simulate a click at the current reticle position
            handleFlick({
                clientX: reticleX + canvas.getBoundingClientRect().left,
                clientY: reticleY + canvas.getBoundingClientRect().top,
            });
        }
        
        /**
         * Updates the stat panel
         */
        function updateStats() {
            shotsTakenEl.textContent = shotsTaken;
            shotsLeftEl.textContent = MAX_SHOTS - shotsTaken;
            
            if (reactionTimes.length > 0) {
                const avg = reactionTimes.reduce((a, b) => a + b, 0) / reactionTimes.length;
                avgReactionEl.textContent = avg.toFixed(2);
            } else {
                avgReactionEl.textContent = 'N/A';
            }
            
            const avgOvershoot = overshootErrors.length > 0 
                ? overshootErrors.reduce((a, b) => a + b, 0) / overshootErrors.length
                : 0;
            const avgUndershoot = undershootErrors.length > 0
                ? undershootErrors.reduce((a, b) => a + b, 0) / undershootErrors.length
                : 0;

            avgOvershootEl.textContent = avgOvershoot.toFixed(2);
            avgUndershootEl.textContent = avgUndershoot.toFixed(2);
        }

        /**
         * Logic to start the full test.
         */
        let gameStartTime = 0;

        function startGame() {
            if (isGameRunning) return;

            // Reset all state
            isGameRunning = true;
            shotsTaken = 0;
            reactionTimes = [];
            overshootErrors = [];
            undershootErrors = [];
            
            gameStartTime = performance.now();

            startButton.textContent = 'IN PROGRESS...';
            startButton.disabled = true;
            resultsModal.style.display = 'none';

            // Show custom reticle and set it to center
            reticle.classList.remove('hidden');
            reticleX = canvas.width / 2;
            reticleY = canvas.height / 2;
            updateReticlePosition();
            
            // Start game loop and first round
            if (gameLoopInterval) cancelAnimationFrame(gameLoopInterval);
            gameLoopInterval = requestAnimationFrame(gameLoop);
            
            startNewRound();
        }

        /**
         * Logic to analyze results and end the game.
         */
        function endGame() {
            isGameRunning = false;
            target = null;
            cancelAnimationFrame(gameLoopInterval);
            reticle.classList.add('hidden');

            const avgOvershoot = overshootErrors.length > 0 
                ? overshootErrors.reduce((a, b) => a + b, 0) / overshootErrors.length
                : 0;
            const avgUndershoot = undershootErrors.length > 0
                ? undershootErrors.reduce((a, b) => a + b, 0) / undershootErrors.length
                : 0;
            
            const totalAvgError = avgOvershoot + avgUndershoot;
            const errorThreshold = 10; // Pixels

            let suggestionText;
            let suggestionLabel;
            
            if (totalAvgError < errorThreshold && reactionTimes.length > 0) {
                suggestionLabel = "OPTIMAL";
                suggestionText = `Excellent control! Your average directional error is only ${totalAvgError.toFixed(2)}px. Your current sensitivity appears to be close to optimal for your mouse control style.`;
            } else if (avgOvershoot > avgUndershoot && avgOvershoot > errorThreshold) {
                suggestionLabel = "DECREASE SENSITIVITY";
                suggestionText = `You consistently ${avgOvershoot.toFixed(2)}px past the target center. This suggests your sensitivity is too high. Try lowering your in-game sensitivity by 5-10% and run the test again.`;
            } else if (avgUndershoot > avgOvershoot && avgUndershoot > errorThreshold) {
                suggestionLabel = "INCREASE SENSITIVITY";
                suggestionText = `You consistently fell short of the target center by ${avgUndershoot.toFixed(2)}px. This suggests your sensitivity is too low. Try raising your in-game sensitivity by 5-10% and run the test again.`;
            } else {
                 suggestionLabel = "CONSISTENT FLICK (GOOD)";
                 suggestionText = `Your directional error is balanced but high. This may indicate a slight inconsistency in your flick speed. Your sensitivity is likely close, but practice focusing on stopping power.`;
            }

            suggestionEl.textContent = suggestionLabel;
            
            // Show modal
            const totalTime = (performance.now() - gameStartTime) / 1000;
            const avgTime = reactionTimes.length > 0 ? reactionTimes.reduce((a, b) => a + b, 0) / reactionTimes.length : 0;
            
            modalStatsEl.innerHTML = `
                <p><strong>Total Time:</strong> ${totalTime.toFixed(2)} s</p>
                <p><strong>Average Reaction Time:</strong> ${avgTime.toFixed(2)} ms</p>
            `;

            suggestionTextEl.innerHTML = `<strong>Sensitivity Suggestion: ${suggestionLabel}</strong><br>${suggestionText}`;
            resultsModal.style.display = 'flex';
            startButton.textContent = 'RESTART TEST';
            startButton.disabled = false;
        }
        
        /**
         * Resets and closes the results modal.
         */
        function closeModal() {
            resultsModal.style.display = 'none';
            // Optional: reset stats display if needed, but 'RESTART TEST' will do it
        }

        /**
         * Initialization and Event Listeners
         */
        function initialize() {
            // Make canvas responsive by resizing and re-centering
            function resizeCanvas() {
                const containerWidth = canvas.parentElement.clientWidth;
                const newWidth = Math.min(700, containerWidth);
                const newHeight = Math.min(500, Math.max(300, containerWidth * (500/700)));
                
                canvas.width = newWidth;
                canvas.height = newHeight;
                
                // Re-center reticle on resize
                reticleX = canvas.width / 2;
                reticleY = canvas.height / 2;
                updateReticlePosition();

                // Restart drawing loop if running
                if (isGameRunning && target) {
                    target = new Target(target.x * (newWidth / 700), target.y * (newHeight / 500), TARGET_RADIUS);
                }
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas(); // Initial resize

            startButton.addEventListener('click', startGame);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('click', handleFlick);
            
            // Touch handlers for mobile
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd);

            // Initial UI setup
            shotsLeftEl.textContent = MAX_SHOTS;
            
            // Run initial draw to set background
            gameLoop();
        }

        window.onload = initialize;
    </script>
</body>
</html>